<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weaving Tracker v.1.3</title>
    <style>
        /* General Styles */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Settings Styles */
        .settings-container {
            width: 300px;
            margin-bottom: 20px;
        }

        .slider-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .slider-label {
            font-size: 14px;
            color: #777;
            width: 80px;
            text-align: left;
        }

        input[type="range"] {
            width: 70%;
            height: 5px;
            -webkit-appearance: none;
            background: #ddd;
            outline: none;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            width: 40px;
            text-align: center;
            color: #777;
        }

        .number-input-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .number-label {
            font-size: 14px;
            color: #777;
            width: 80px;
            text-align: left;
        }

input[type="number"] {
     width: 100%; /* Fill the container */
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    text-align: center;
    font-size: 14px;
    background-color: transparent; /* Makes the box transparent */
    color: #000; /* Ensures the number is visible (change if needed) */
	border: 0px solid #ddd;
}

        /* Grid Styles */
        #grid-container {
            display: flex;
            flex-direction: column-reverse;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow-x: auto; /* Enable horizontal scrolling */
        }

        .row {
            display: flex;
        }

        .cell {
            width: 25px;
            height: 25px;
            border: 1px solid #ddd;
            box-sizing: border-box;
            background-color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
			font-weight: bold;
            transition: width 0.3s ease; /* Smooth transition for width changes */
        }

        .cell.mobile-optimized {
            width: calc(100vw / var(--threaddles)); /* Dynamic width calculation */
        }

        .selected {
            background-color: lightgreen;
        }

        .marked {
            background-color: black;
            color: white;
        }

        /* Controls Styles */
        #controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 300px;
            width: 100%;
            margin: 0 auto 20px auto;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }

        #controls button,
        #controls label {
            padding: 10px;
            font-size: 14px;
            text-align: center;
        }

        #start-stop {
            width: 100%;
            padding: 15px 24px;
            font-size: 18px;
            font-weight: bold;
        }
		
		#numbering-toggle-container {
            width: 100%;
			}
		
		#numbering-toggle {
            width: 100%;
        }

        #start-stop.start {
            background-color: green;
            color: white;
        }

        #start-stop.stop {
            background-color: red;
            color: white;
        }

        #mute-toggle-container {
            width: 100%;
        }

        #mute-toggle {
            width: 100%;
            padding: 15px 24px;
            font-size: 18px;
        }

        button,
        label[for="import"] {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            flex: 1;
            min-width: 100px;
        }

        button:hover,
        label[for="import"]:hover {
            background-color: #0056b3;
        }

        input[type="file"] {
            display: none;
        }

        /* How To Use Styles */
        .how-to-use {
            text-align: center;
            color: #555;
            font-size: 14px;
            line-height: 1.6;
            width: 80%;
            margin: 0 auto;
            font-style: italic;
        }
    </style>
</head>

<body>
    <h1 id="pattern-title">Weaving Tracker v.1.4</h1>

    <div class="settings-container">
        <div class="slider-group">
            <label for="threaddles" class="slider-label">Treadles:</label>
            <input type="range" id="threaddles" min="1" max="20" value="4">
            <span id="threaddles-value" class="slider-value">4</span>
        </div>

        <div class="number-input-group">
            <label for="rows" class="number-label">Picks:</label>
            <input type="number" id="rows" value="4" min="1" max="9999">
        </div>
    </div>

    <div id="grid-container">
        <!-- Grid will be generated here -->
    </div>

    <div id="controls">
        <button id="start-stop" class="start">START</button>
        <div class="button-group">
            <input type="file" id="import" accept=".wif,.txt">
            <label for="import">Import WIF</label>
            <button id="export">Export WIF</button>
            <button id="add-rows">+</button>
        </div>
        <div id="mute-toggle-container">
            <button id="mute-toggle">Mute</button>
        </div>
        <div id="numbering-toggle-container">
            <button id="numbering-toggle">Numbering</button>
        </div>
    </div>

    <div class="how-to-use">Getting Started:<br>Open the html-file in your browser.<br>
        Use the sliders to adjust the number of treadles and threads.<br>
        Start at the bottom if you want to do treadles manually.<br>
        Import and export WIF files for convenience.<br>
        Press Start to begin weaving (Press Stop to edit the pattern)<br>
        Click the pattern to advance the green selector row by row (so you know where you
        are).<br>This is under Apache-2.0 license. <a
            href="https://github.com/starinspace/Weaving-Tracker">Github</a>
    </div>

    <script>
        const patternTitleDisplay = document.getElementById('pattern-title');
        const threaddlesInput = document.getElementById('threaddles');
        const rowsInput = document.getElementById('rows');
        const threaddlesValueDisplay = document.getElementById('threaddles-value');
        const gridContainer = document.getElementById('grid-container');
        const startStopButton = document.getElementById('start-stop');
        const exportButton = document.getElementById('export');
        const importInput = document.getElementById('import');
        const addRowsButton = document.getElementById('add-rows');
        const muteToggleButton = document.getElementById('mute-toggle');
        const numberingToggleButton = document.getElementById('numbering-toggle');
        let isMuted = false;
        let isNumbering = true;
        let isRunning = false; // Track if the weaving is running
        let threaddles = parseInt(threaddlesInput.value);
        let rows = parseInt(rowsInput.value);
        let grid = [];
        let currentRow = 0;
        let currentPatternTitle = "Weaving Tracker";

        function playClick() {
            if (isMuted) return;
            const context = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(1000, context.currentTime);
            gainNode.gain.setValueAtTime(0.1, context.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 0.1);
            oscillator.connect(gainNode);
            gainNode.connect(context.destination);
            oscillator.start();
            oscillator.stop(context.currentTime + 0.1);
        }

        function updateSliderValue(slider, displayElement) {
            displayElement.textContent = slider.value;
        }

        function generateGrid() {
            gridContainer.innerHTML = '';
            grid = [];

            gridContainer.style.setProperty('--threaddles', threaddles); // Set CSS variable

            for (let i = 0; i < rows; i++) {
                const rowElement = document.createElement('div');
                rowElement.classList.add('row');
                const rowData = [];
                for (let j = 0; j < threaddles; j++) {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('cell');
                    cellElement.dataset.row = i;
                    cellElement.dataset.threaddle = j;
                    cellElement.dataset.marked = false;
                    cellElement.addEventListener('click', toggleMarked);
                    rowElement.appendChild(cellElement);
                    rowData.push(false);
                }
                gridContainer.appendChild(rowElement);
                grid.push(rowData);
            }

            gridContainer.removeEventListener('click', nextRow);
            gridContainer.addEventListener('click', nextRow);
            updateGridDisplay();
        }

        function updateThreaddles() {
            const savedGridData = saveGridData();
            threaddles = parseInt(threaddlesInput.value);
            updateSliderValue(threaddlesInput, threaddlesValueDisplay);
            generateGrid();
            restoreGridData(savedGridData);
        }

        function updateRows() {
            const savedGridData = saveGridData();
            rows = parseInt(rowsInput.value);
            generateGrid();
            restoreGridData(savedGridData);
        }

        updateSliderValue(threaddlesInput, threaddlesValueDisplay);

        threaddlesInput.addEventListener('input', updateThreaddles);
        rowsInput.addEventListener('input', function () {
            rows = parseInt(this.value);
            updateRows();
        });

        function updateGridDisplay() {
            const rowElements = document.querySelectorAll('#grid-container .row');
            rowElements.forEach((rowElement, rowIndex) => {
                const cellElements = rowElement.querySelectorAll('.cell');
                cellElements.forEach((cellElement, threaddleIndex) => {
                    if (isRunning) {
                        cellElement.classList.add('mobile-optimized');
                    } else {
                        cellElement.classList.remove('mobile-optimized');
                    }

                    if (rowIndex === currentRow) {
                        cellElement.classList.add('selected');
                    } else {
                        cellElement.classList.remove('selected');
                    }

                    const isMarked = cellElement.dataset.marked === 'true';
                    cellElement.classList.toggle('marked', isMarked);

                    if (isMarked && isNumbering) {
                        cellElement.textContent = (threaddleIndex + 1).toString();
                    } else {
                        cellElement.textContent = '';
                    }
                });
            });
            updateCellDatasetRows();
        }

        function startStop() {
            isRunning = !isRunning;
            if (isRunning) {
                startStopButton.textContent = "STOP";
                startStopButton.classList.remove("start");
                startStopButton.classList.add("stop");
                // Apply mobile optimization
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => cell.classList.add('mobile-optimized'));
                updateGridDisplay(); // Re-render the grid to apply mobile styles
            } else {
                startStopButton.textContent = "START";
                startStopButton.classList.remove("stop");
                startStopButton.classList.add("start");
                // Remove mobile optimization
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => cell.classList.remove('mobile-optimized'));
                updateGridDisplay(); // Re-render grid to revert to desktop styles

            }

            const allCells = document.querySelectorAll('.cell');
            allCells.forEach(cell => {
                cell.removeEventListener('click', toggleMarked);
            });
            if (isRunning) {
                gridContainer.removeEventListener('click', nextRow)
                gridContainer.addEventListener('click', nextRow);
            }

            if (isRunning) {
                currentRow = 0;
                updateGridDisplay();
                scrollToCurrentRow(); // Scroll to the current row on start
            } else {
                allCells.forEach(cell => {
                    cell.addEventListener('click', toggleMarked);
                });
                gridContainer.removeEventListener('click', nextRow)
                updateGridDisplay();
            }
        }

        function nextRow() {
            if (!isRunning) return;
            currentRow++;
            if (currentRow >= rows) {
                currentRow = 0;
            }
            updateGridDisplay();
            scrollToCurrentRow(); // Scroll to the current row after each advance
            playClick();
        }

        function toggleMarked(event) {
            const cellElement = event.target;
            const marked = cellElement.dataset.marked === 'true';
            cellElement.dataset.marked = !marked;
            updateGridDisplay();
        }

        function exportGrid() {
            console.log("exportGrid function called.");
            let fileContent = "[WEAVING]\n";
            fileContent += "Treadles=" + threaddles + "\n";
            fileContent += "Threads=" + rows + "\n";
            fileContent += "\n[TEXT]\n";
            fileContent += "Title=" + currentPatternTitle + "\n";
            fileContent += "\n[THREADING]\n";

            for (let j = 0; j < threaddles; j++) {
                let threadingValue = "";
                for (let i = 0; i < rows; i++) {
                    const cellElement = document.querySelector(
                        `#grid-container .row:nth-child(${rows - i}) .cell:nth-child(${j + 1})`);
                    if (cellElement && cellElement.dataset.marked === 'true') {
                        threadingValue = (i + 1).toString();
                        break;
                    }
                }
                fileContent += (j + 1) + "=" + threadingValue + "\n";
            }

            fileContent += "\n[TREADLING]\n";

            for (let i = 0; i < rows; i++) {
                let treadleNumber = "";
                for (let j = 0; j < threaddles; j++) {
                    const cellElement = document.querySelector(
                        `#grid-container .row:nth-child(${rows - i}) .cell:nth-child(${j + 1})`);
                    if (cellElement && cellElement.dataset.marked === 'true') {
                        treadleNumber = (j + 1).toString();
                        break;
                    }
                }
                fileContent += (i + 1) + "=" + treadleNumber + "\n";
            }

            const blob = new Blob([fileContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentPatternTitle + '.wif';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Export process complete.");
        }

        function parsePatternFile(fileContent) {
            const patternData = {};
            const sections = fileContent.split(/\[(.*?)\]/g);

            for (let i = 1; i < sections.length; i += 2) {
                const sectionName = sections[i].trim();
                const sectionContent = sections[i + 1] || "";
                patternData[sectionName] = {};

                const lines = sectionContent.trim().split('\n');
                for (const line of lines) {
                    if (line.trim() === "") continue;
                    const [key, value] = line.trim().split('=').map(s => s.trim());
                    if (key && value) {
                        patternData[sectionName][key] = value;
                    }
                }
            }
            if (patternData["TEXT"] && patternData["TEXT"]["Title"]) {
                currentPatternTitle = patternData["TEXT"]["Title"];
                patternTitleDisplay.textContent = currentPatternTitle;
            }
            return patternData;
        }

        function treadlingToBinary(treadlingData, numThreads) {
            const binaryPattern = [];
            for (const rowKey in treadlingData) {
                let binaryRow = "";
                for (let j = 1; j <= numThreads; j++) {
                    binaryRow += (treadlingData[rowKey] === j.toString()) ? "1" : "0";
                }
                binaryPattern.push(binaryRow);
            }
            return binaryPattern;
        }

        function importGrid(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const fileContent = e.target.result;
                const fileType = file.name.split('.').pop().toLowerCase();
                let importedRows, importedThreaddles;

                if (fileType === 'wif') {
                    try {
                        const patternData = parsePatternFile(fileContent);
                        if (patternData["TEXT"] && patternData["TEXT"]["Title"]) {
                            currentPatternTitle = patternData["TEXT"]["Title"];
                            patternTitleDisplay.textContent = currentPatternTitle;
                        }
                        if (!patternData["WEAVING"] || !patternData["WEAVING"]["Treadles"]) {
                            throw new Error("Number of treadles missing in [WEAVING] section.");
                        }
                        if (!patternData["TREADLING"]) {
                            throw new Error("Treadling data missing in [TREADLING] section.");
                        }
                        importedThreaddles = parseInt(patternData["WEAVING"]["Treadles"]);
                        importedRows = Object.keys(patternData["TREADLING"]).length;
                        threaddlesInput.value = importedThreaddles;
                        rowsInput.value = importedRows;
                        updateSliderValue(threaddlesInput, threaddlesValueDisplay);
                        updateRows();
                        updateThreaddles();
                        const binaryTreadling = treadlingToBinary(patternData["TREADLING"], importedThreaddles);
                        applyBinaryTreadlingToGrid(binaryTreadling);
                        alert("Grid imported successfully from WIF!");
                        return;
                    } catch (error) {
                        alert("Error parsing WIF file: " + error);
                        return;
                    }
                } else {
                    try {
                        parseAndApplyTxtGrid(fileContent);
                        alert("Grid imported successfully!");
                        return;
                    } catch (error) {
                        alert("Error parsing TXT file: " + error);
                        return;
                    }
                }
            };
            reader.readAsText(file);

            function applyBinaryTreadlingToGrid(binaryTreadling) {
                const numRowsToApply = Math.min(binaryTreadling.length, rows);
                console.log(
                    `applyBinaryTreadlingToGrid: numRowsToApply = ${numRowsToApply}, binaryTreadling.length = ${binaryTreadling.length}, rows = ${rows}`);
                for (let rowIndex = 0; rowIndex < numRowsToApply; rowIndex++) {
                    const row = binaryTreadling[rowIndex];
                    if (!row) {
                        console.warn(`Treadling row ${rowIndex + 1} is undefined.`);
                        continue;
                    }
                    if (rowIndex >= rows) {
                        console.warn(`Treadling row ${rowIndex + 1} exceeds grid height.`);
                        continue;
                    }
                    const rowElements = document.querySelectorAll(
                        `#grid-container .row:nth-child(${rows - rowIndex}) .cell`);
                    console.log(
                        `  Row ${rowIndex + 1}: rowElements.length = ${rowElements.length}, threaddles = ${threaddles}`);
                    for (let i = 0; i < threaddles; i++) {
                        if (i >= rowElements.length) {
                            console.warn(`    Treadle ${i + 1} exceeds grid width.`);
                            break;
                        }
                        console.log(`    Cell ${i + 1}: binaryTreadling[${rowIndex}][${i}] = ${row[i]}`);
                        rowElements[i].dataset.marked = row[i] === '1';
                    }
                }
                updateGridDisplay();
            }

            function parseAndApplyTxtGrid(fileContent) {
                const lines = fileContent.trim().split('\n');
                if (lines.length !== rows) {
                    throw new Error("Imported TXT file has incorrect number of rows.");
                }
                lines.forEach((line, rowIdx) => {
                    const bits = line.split('');
                    if (bits.length != threaddles) throw new Error("Number of threaddles does not match")
                    const rowElements = document.querySelectorAll(
                        `#grid-container .row:nth-child(${rows - rowIdx}) .cell`);
                    bits.forEach((bit, colIdx) => {
                        if (rowElements[colIdx])
                            rowElements[colIdx].dataset.marked = bit === '1';
                    });
                });
                updateGridDisplay();
            }
        }

        function saveGridData() {
            const savedData = [];
            const rowElements = document.querySelectorAll('#grid-container .row');
            rowElements.forEach((rowElement, rowIndex) => {
                const rowData = [];
                const cellElements = rowElement.querySelectorAll('.cell');
                cellElements.forEach(cellElement => {
                    rowData.push(cellElement.dataset.marked === 'true');
                });
                savedData.push(rowData);
            });
            return savedData;
        }

        function restoreGridData(savedData) {
            if (!savedData || savedData.length === 0) return;
            const rowElements = document.querySelectorAll('#grid-container .row');
            rowElements.forEach((rowElement, rowIndex) => {
                if (rowIndex >= savedData.length) return;
                const rowData = savedData[rowIndex];
                const cellElements = rowElement.querySelectorAll('.cell');
                cellElements.forEach((cellElement, cellIndex) => {
                    if (cellIndex < rowData.length) {
                        cellElement.dataset.marked = rowData[cellIndex];
                    } else {
                        cellElement.dataset.marked = false;
                    }
                });
            });
            updateGridDisplay();
        }

        function updateCellDatasetRows() {
            document.querySelectorAll(".row").forEach((row, index) => {
                row.querySelectorAll(".cell").forEach(cell => {
                    cell.dataset.row = rows - 1 - index;
                })
            })
        }

        function addRows() {
            rows++;
            rowsInput.value = rows;
            const gridContainer = document.getElementById('grid-container');
            const rowElement = document.createElement('div');
            rowElement.classList.add('row');
            const rowData = [];
            for (let j = 0; j < threaddles; j++) {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell');
                cellElement.dataset.row = rows - 1;
                cellElement.dataset.threaddle = j;
                cellElement.dataset.marked = false;
                cellElement.addEventListener('click', toggleMarked);
                rowElement.appendChild(cellElement);
                rowData.push(false);
            }
            gridContainer.prepend(rowElement);
            grid.unshift(rowData);
            updateGridDisplay()
        }

        function toggleMute() {
            isMuted = !isMuted;
            muteToggleButton.textContent = isMuted ? "Unmute" : "Mute";
        }

        function toggleNumbering() {
            isNumbering = !isNumbering;
            numberingToggleButton.textContent = isNumbering ? "Dots" : "Numbering";
            updateGridDisplay();
        }

        function scrollToCurrentRow() {
            const selectedRow = document.querySelector('.row:nth-child(' + (rows - currentRow) + ')');
            if (selectedRow) {
                const containerWidth = gridContainer.offsetWidth;
                const rowWidth = selectedRow.offsetWidth;
                const scrollLeft = selectedRow.offsetLeft - (containerWidth - rowWidth) / 2;

                gridContainer.scrollTo({
                    left: Math.max(0, scrollLeft), // Prevent scrolling past the beginning
                    behavior: 'smooth'
                });
            }
        }

        startStopButton.addEventListener('click', startStop);
        exportButton.addEventListener('click', exportGrid);
        importInput.addEventListener('change', importGrid);
        addRowsButton.addEventListener('click', addRows);
        muteToggleButton.addEventListener('click', toggleMute);
        numberingToggleButton.addEventListener('click', toggleNumbering);

        generateGrid();
    </script>
</body>

</html>
