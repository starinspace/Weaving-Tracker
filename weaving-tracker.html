<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weaving Tracker v.1.3</title>
    <style>
        /* General Styles */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Minimalistic Slider Styles */
        .settings-container {
            width: 300px;
            margin-bottom: 20px;
        }

        .slider-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .slider-label {
            font-size: 14px;
            color: #777;
            width: 80px; /* Adjust width as needed */
            text-align: left;
        }

        input[type="range"] {
            width: 70%;
            height: 5px;
            -webkit-appearance: none;
            background: #ddd;
            outline: none;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            width: 40px;
            text-align: center;
            color: #777;
        }

        /* Number Input Styles */
        .number-input-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .number-label {
            font-size: 14px;
            color: #777;
            width: 80px; /* Adjust width as needed */
            text-align: left;
        }

        input[type="number"] {
            width: 100%; /* Fill the container */
			padding: 8px;
			border: 1px solid #ddd;
			border-radius: 4px;
			text-align: center;
			font-size: 14px;
			background-color: transparent; /* Makes the box transparent */
			color: #000; /* Ensures the number is visible (change if needed) */
			border: 0px solid #ddd;
        }


        /* Grid Styles */
        #grid-container {
            display: flex;
            flex-direction: column-reverse;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .row {
            display: flex;
        }

        .cell {
            width: 25px;
            height: 25px;
            border: 1px solid #ddd;
            box-sizing: border-box;
            background-color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
			font-weight: bold;
        }

        .selected {
            background-color: lightgreen;
        }

        .marked {
            background-color: black;
            color: white; /* Added to make text visible on black background */
        }

        /* Modern Button Styles */
#controls {
    display: flex;
    flex-direction: column; /* Stapla element vertikalt */
    align-items: center; /* Centrera horisontellt */
    gap: 15px;
    max-width: 300px; /* Öka maxbredden för att rymma alla knappar */
    width: 100%;
    margin: 0 auto 20px auto;
}

.button-group {
    display: flex; /* Visa knappar sida vid sida */
    flex-wrap: wrap; /* Låt knappar brytas till nästa rad om det behövs */
    gap: 10px; /* Mellanrum mellan knapparna */
    justify-content: center; /* Centrera knapparna horisontellt */
    width: 100%; /* Låt gruppen ta upp hela bredden */
}


#controls button,
#controls label {
    padding: 10px;
    font-size: 14px;
    text-align: center;
}


/* START/STOP Button Styles */
#start-stop {
    width: 100%; /* Lång knapp */
    padding: 15px 24px;
    font-size: 18px; /* Större text */
    font-weight: bold; /* Fet text */
}

#start-stop.start {
    background-color: green;
    color: white;
}

#start-stop.stop {
    background-color: red;
    color: white;
}

/* Mute Button Styles */
#mute-toggle-container {
    width: 100%; /* Samma bredd som start-knappen */
}

#mute-toggle {
    width: 100%; /* Mute-knappen tar upp hela containerns bredd */
    padding: 15px 24px; /* Samma padding som start-knappen */
    font-size: 18px;
}


/* Standard Button Styles (för övriga knappar) */
button,
label[for="import"] {
    background-color: #007bff;
    color: white;
    border: none;
    padding: 12px 24px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    cursor: pointer;
    border-radius: 8px;
    transition: background-color 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    flex: 1; /* För att fördela utrymmet jämnt mellan knapparna */
    min-width: 100px; /* Minsta bredd för knappar */
}

button:hover,
label[for="import"]:hover {
    background-color: #0056b3;
}

input[type="file"] {
    display: none;
}

        /* How To Use Text Styles */
        .how-to-use {
            text-align: center;
            color: #555;
            font-size: 14px;
            line-height: 1.6;
            width: 80%;
            margin: 0 auto;
            font-style: italic;
        }
    </style>
</head>

<body>
    <h1 id="pattern-title">Weaving Tracker v.1.4</h1>

    <div class="settings-container">
        <div class="slider-group">
            <label for="threaddles" class="slider-label">Treadles:</label>
            <input type="range" id="threaddles" min="1" max="20" value="6">
            <span id="threaddles-value" class="slider-value">8</span>
        </div>

        <!-- Replaced slider with number input -->
        <div class="number-input-group">
            <label for="rows" class="number-label">Picks:</label>
            <input type="number" id="rows" value="20" min="1" max="999">
        </div>
    </div>

    <div id="grid-container">
        <!-- Grid will be generated here -->
    </div>

    <div id="controls">
        <button id="start-stop" class="start">START</button>
        <div class="button-group">
            <input type="file" id="import" accept=".wif,.txt">
            <label for="import">Import WIF</label>
            <button id="export">Export WIF</button>
            <button id="add-rows">+</button>
        </div>
        <div id="mute-toggle-container">
            <button id="mute-toggle">Mute</button>
        </div>
        <div id="numbering-toggle-container">
            <button id="numbering-toggle">Dots</button>
        </div>
    </div>

    <div class="how-to-use">Getting Started:<br>Open the html-file in your browser.<br>
        Use the sliders to adjust the number of treadles and threads.<br>
        Start at the bottom if you want to do treadles manually.<br>
        Import and export WIF files for convenience.<br>
        Press Start to begin weaving (Press Stop to edit the pattern)<br>
        Click the pattern to advance the green selector row by row (so you know where you
        are).<br>This is under Apache-2.0 license. <a
            href="https://github.com/starinspace/Weaving-Tracker">Github</a>
    </div>

    <script>
        const patternTitleDisplay = document.getElementById('pattern-title');
        const threaddlesInput = document.getElementById('threaddles');
        const rowsInput = document.getElementById('rows');
        const threaddlesValueDisplay = document.getElementById('threaddles-value');
        const gridContainer = document.getElementById('grid-container');
        const startStopButton = document.getElementById('start-stop');
        const exportButton = document.getElementById('export');
        const importInput = document.getElementById('import');
        const addRowsButton = document.getElementById('add-rows');
        const muteToggleButton = document.getElementById('mute-toggle');
        const numberingToggleButton = document.getElementById('numbering-toggle'); // New button
        let isMuted = false;
        let isNumbering = true; // New state

        let threaddles = parseInt(threaddlesInput.value);
        let rows = parseInt(rowsInput.value);
        let grid = [];
        let currentRow = 0;
        let isRunning = false;
        let currentPatternTitle = "Weaving Tracker";

        function playClick() {
            if (isMuted) return;

            const context = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();

            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(1000, context.currentTime);

            gainNode.gain.setValueAtTime(0.1, context.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 0.1);

            oscillator.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.start();
            oscillator.stop(context.currentTime + 0.1);
        }

        function updateSliderValue(slider, displayElement) {
            displayElement.textContent = slider.value;
        }

        function generateGrid() {
            gridContainer.innerHTML = '';
            grid = [];

            for (let i = 0; i < rows; i++) {
                const rowElement = document.createElement('div');
                rowElement.classList.add('row');
                const rowData = [];
                for (let j = 0; j < threaddles; j++) {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('cell');
                    cellElement.dataset.row = i;
                    cellElement.dataset.threaddle = j;
                    cellElement.dataset.marked = false;
                    cellElement.addEventListener('click', toggleMarked);
                    rowElement.appendChild(cellElement);
                    rowData.push(false);
                }
                gridContainer.appendChild(rowElement);
                grid.push(rowData);
            }

            gridContainer.removeEventListener('click', nextRow);
            gridContainer.addEventListener('click', nextRow);
            updateGridDisplay(); // Call updateGridDisplay after generating the grid
        }

        function updateThreaddles() {
            const savedGridData = saveGridData();

            threaddles = parseInt(threaddlesInput.value);
            updateSliderValue(threaddlesInput, threaddlesValueDisplay);
            generateGrid();

            restoreGridData(savedGridData);
        }

        function updateRows() {
            const savedGridData = saveGridData();

            rows = parseInt(rowsInput.value);
            generateGrid();

            restoreGridData(savedGridData);
        }

        updateSliderValue(threaddlesInput, threaddlesValueDisplay);

        threaddlesInput.addEventListener('input', updateThreaddles);
        rowsInput.addEventListener('input', function() {
            rows = parseInt(this.value);
            updateRows();
        });

        function updateGridDisplay() {
            const rowElements = document.querySelectorAll('#grid-container .row');
            rowElements.forEach((rowElement, rowIndex) => {
                const cellElements = rowElement.querySelectorAll('.cell');
                cellElements.forEach((cellElement, threaddleIndex) => {
                    if (rowIndex === currentRow) {
                        cellElement.classList.add('selected');
                    } else {
                        cellElement.classList.remove('selected');
                    }

                    const isMarked = cellElement.dataset.marked === 'true';
                    cellElement.classList.toggle('marked', isMarked);


                    if (isMarked && isNumbering) {
                        cellElement.textContent = (threaddleIndex + 1).toString();
                    } else {
                        cellElement.textContent = ''; // Clear text if not numbered
                    }

                });
            });
            updateCellDatasetRows();
        }


        function startStop() {
            isRunning = !isRunning;
            if (isRunning) {
                startStopButton.textContent = "STOP";
                startStopButton.classList.remove("start");
                startStopButton.classList.add("stop");
            } else {
                startStopButton.textContent = "START";
                startStopButton.classList.remove("stop");
                startStopButton.classList.add("start");
            }

            const allCells = document.querySelectorAll('.cell');
            allCells.forEach(cell => {
                cell.removeEventListener('click', toggleMarked);
            });
            if (isRunning) {
                gridContainer.removeEventListener('click', nextRow)
                gridContainer.addEventListener('click', nextRow);
            }


            if (isRunning) {
                currentRow = 0;
                updateGridDisplay();
            } else {
                allCells.forEach(cell => {
                    cell.addEventListener('click', toggleMarked);
                });
                gridContainer.removeEventListener('click', nextRow)
                updateGridDisplay();
            }
        }

        function nextRow() {
            if (!isRunning) return;

            currentRow++;
            if (currentRow >= rows) {
                currentRow = 0;
            }
            updateGridDisplay();
            playClick();
        }

        function toggleMarked(event) {
            const cellElement = event.target;
            const marked = cellElement.dataset.marked === 'true';
            cellElement.dataset.marked = !marked;
            updateGridDisplay();
        }

        function exportGrid() {
            console.log("exportGrid function called.");
            let fileContent = "[WEAVING]\n";
            fileContent += "Treadles=" + threaddles + "\n";
            fileContent += "Threads=" + rows + "\n";
            fileContent += "\n[TEXT]\n";
            fileContent += "Title=" + currentPatternTitle + "\n";
            fileContent += "\n[THREADING]\n";

            for (let j = 0; j < threaddles; j++) {
                let threadingValue = "";
                for (let i = 0; i < rows; i++) {
                    const cellElement = document.querySelector(
                        `#grid-container .row:nth-child(${rows - i}) .cell:nth-child(${j + 1})`);
                    if (cellElement && cellElement.dataset.marked === 'true') {
                        threadingValue = (i + 1).toString();
                        break;
                    }
                }
                fileContent += (j + 1) + "=" + threadingValue + "\n";
            }

            fileContent += "\n[TREADLING]\n";

            for (let i = 0; i < rows; i++) {
                let treadleNumber = "";
                for (let j = 0; j < threaddles; j++) {
                    const cellElement = document.querySelector(
                        `#grid-container .row:nth-child(${rows - i}) .cell:nth-child(${j + 1})`);
                    if (cellElement && cellElement.dataset.marked === 'true') {
                        treadleNumber = (j + 1).toString();
                        break;
                    }
                }
                fileContent += (i + 1) + "=" + treadleNumber + "\n";
            }

            const blob = new Blob([fileContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentPatternTitle + '.wif';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Export process complete.");
        }

        function parsePatternFile(fileContent) {
            const patternData = {};
            const sections = fileContent.split(/\[(.*?)\]/g);

            for (let i = 1; i < sections.length; i += 2) {
                const sectionName = sections[i].trim();
                const sectionContent = sections[i + 1] || "";
                patternData[sectionName] = {};

                const lines = sectionContent.trim().split('\n');
                for (const line of lines) {
                    if (line.trim() === "") continue;
                    const [key, value] = line.trim().split('=').map(s => s.trim());
                    if (key && value) {
                        patternData[sectionName][key] = value;
                    }
                }
            }
            if (patternData["TEXT"] && patternData["TEXT"]["Title"]) {
                currentPatternTitle = patternData["TEXT"]["Title"];
                patternTitleDisplay.textContent = currentPatternTitle;
            }
            return patternData;
        }

        function treadlingToBinary(treadlingData, numThreads) {
            const binaryPattern = [];
            for (const rowKey in treadlingData) {
                let binaryRow = "";
                for (let j = 1; j <= numThreads; j++) {
                    binaryRow += (treadlingData[rowKey] === j.toString()) ? "1" : "0";
                }
                binaryPattern.push(binaryRow);
            }
            return binaryPattern;
        }

        function importGrid(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const fileContent = e.target.result;
                const fileType = file.name.split('.').pop().toLowerCase();

                let importedRows, importedThreaddles;

                if (fileType === 'wif') {
                    try {
                        const patternData = parsePatternFile(fileContent);
                        if (patternData["TEXT"] && patternData["TEXT"]["Title"]) {
                            currentPatternTitle = patternData["TEXT"]["Title"];
                            patternTitleDisplay.textContent = currentPatternTitle;
                        }

                        if (!patternData["WEAVING"] || !patternData["WEAVING"]["Treadles"]) {
                            throw new Error("Number of treadles missing in [WEAVING] section.");
                        }
                        if (!patternData["TREADLING"]) {
                            throw new Error("Treadling data missing in [TREADLING] section.");
                        }

                        importedThreaddles = parseInt(patternData["WEAVING"]["Treadles"]);
                        importedRows = Object.keys(patternData["TREADLING"]).length;

                        threaddlesInput.value = importedThreaddles;
                        importedRows = Object.keys(patternData["TREADLING"]).length;

                        threaddlesInput.value = importedThreaddles;
                        rowsInput.value = importedRows;

                        updateSliderValue(threaddlesInput, threaddlesValueDisplay);

                        updateRows();

                        updateThreaddles();

                        const binaryTreadling = treadlingToBinary(patternData["TREADLING"], importedThreaddles);
                        applyBinaryTreadlingToGrid(binaryTreadling);
                        alert("Grid imported successfully from WIF!");
                        return;
                    } catch (error) {
                        alert("Error parsing WIF file: " + error);
                        return;
                    }
                } else {
                    try {
                        parseAndApplyTxtGrid(fileContent);
                        alert("Grid imported successfully!");
                        return;
                    } catch (error) {
                        alert("Error parsing TXT file: " + error);
                        return;

                    }

                }


            };
            reader.readAsText(file);

            function applyBinaryTreadlingToGrid(binaryTreadling) {
                const numRowsToApply = Math.min(binaryTreadling.length, rows);
                console.log(
                    `applyBinaryTreadlingToGrid: numRowsToApply = ${numRowsToApply}, binaryTreadling.length = ${binaryTreadling.length}, rows = ${rows}`);

                for (let rowIndex = 0; rowIndex < numRowsToApply; rowIndex++) {
                    const row = binaryTreadling[rowIndex];
                    if (!row) {
                        console.warn(`Treadling row ${rowIndex + 1} is undefined.`);
                        continue;
                    }

                    if (rowIndex >= rows) {
                        console.warn(`Treadling row ${rowIndex + 1} exceeds grid height.`);
                        continue;
                    }

                    const rowElements = document.querySelectorAll(
                        `#grid-container .row:nth-child(${rows - rowIndex}) .cell`);
                    console.log(
                        `  Row ${rowIndex + 1}: rowElements.length = ${rowElements.length}, threaddles = ${threaddles}`);

                    for (let i = 0; i < threaddles; i++) {
                        if (i >= rowElements.length) {
                            console.warn(`    Treadle ${i + 1} exceeds grid width.`);
                            break;
                        }
                        console.log(`    Cell ${i + 1}: binaryTreadling[${rowIndex}][${i}] = ${row[i]}`);
                        rowElements[i].dataset.marked = row[i] === '1';
                    }
                }
                updateGridDisplay();
            }

            function parseAndApplyTxtGrid(fileContent) {
                const lines = fileContent.trim().split('\n');

                if (lines.length !== rows) {
                    throw new Error("Imported TXT file has incorrect number of rows.");
                }


                lines.forEach((line, rowIdx) => {
                    const bits = line.split('');
                    if (bits.length != threaddles) throw new Error("Number of threaddles does not match")
                    const rowElements = document.querySelectorAll(
                        `#grid-container .row:nth-child(${rows - rowIdx}) .cell`);

                    bits.forEach((bit, colIdx) => {
                        if (rowElements[colIdx])
                            rowElements[colIdx].dataset.marked = bit === '1';
                    });
                });

                updateGridDisplay();

            }


        }

        function saveGridData() {
            const savedData = [];
            const rowElements = document.querySelectorAll('#grid-container .row');
            rowElements.forEach((rowElement, rowIndex) => {
                const rowData = [];
                const cellElements = rowElement.querySelectorAll('.cell');
                cellElements.forEach(cellElement => {
                    rowData.push(cellElement.dataset.marked === 'true');
                });
                savedData.push(rowData);
            });
            return savedData;
        }

        function restoreGridData(savedData) {
            if (!savedData || savedData.length === 0) return;

            const rowElements = document.querySelectorAll('#grid-container .row');
            rowElements.forEach((rowElement, rowIndex) => {
                if (rowIndex >= savedData.length) return;

                const rowData = savedData[rowIndex];
                const cellElements = rowElement.querySelectorAll('.cell');
                cellElements.forEach((cellElement, cellIndex) => {
                    if (cellIndex < rowData.length) {
                        cellElement.dataset.marked = rowData[cellIndex];
                    } else {
                        cellElement.dataset.marked = false;
                    }
                });
            });
            updateGridDisplay();
        }

        function updateCellDatasetRows() {
            document.querySelectorAll(".row").forEach((row, index) => {
                row.querySelectorAll(".cell").forEach(cell => {
                    cell.dataset.row = rows - 1 - index;
                })
            })
        }

        function addRows() {
            rows++;
            rowsInput.value = rows;

            const gridContainer = document.getElementById('grid-container');
            const rowElement = document.createElement('div');
            rowElement.classList.add('row');

            const rowData = [];

            for (let j = 0; j < threaddles; j++) {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell');
                cellElement.dataset.row = rows - 1;
                cellElement.dataset.threaddle = j;
                cellElement.dataset.marked = false;
                cellElement.addEventListener('click', toggleMarked);
                rowElement.appendChild(cellElement);
                rowData.push(false);
            }

            gridContainer.prepend(rowElement);
            grid.unshift(rowData);

            updateGridDisplay()
        }

        function toggleMute() {
            isMuted = !isMuted;
            muteToggleButton.textContent = isMuted ? "Unmute" : "Mute";
        }


        function toggleNumbering() {
            isNumbering = !isNumbering;
            numberingToggleButton.textContent = isNumbering ? "Dots" : "Numbering";
            updateGridDisplay(); // Update the grid display when numbering is toggled
        }



        startStopButton.addEventListener('click', startStop);
        exportButton.addEventListener('click', exportGrid);
        importInput.addEventListener('change', importGrid);
        addRowsButton.addEventListener('click', addRows);
        muteToggleButton.addEventListener('click', toggleMute);
        numberingToggleButton.addEventListener('click', toggleNumbering); // Event listener for the new button

        generateGrid();
    </script>
</body>

</html>
